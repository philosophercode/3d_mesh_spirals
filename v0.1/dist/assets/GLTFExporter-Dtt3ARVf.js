import{C as se,M as Z,V as v,Q as te,B as S,a as P,d as B,S as ne,N as ie,b as H,R as re,D as oe,P as D,I as ae,c as Y,e as ce,f as ue,g as le,h as he,L as fe,i as pe,j as de,k as xe,l as ge,m as Te,n as Me}from"./index-BOIeGU6y.js";const j={POSITION:["byte","byte normalized","unsigned byte","unsigned byte normalized","short","short normalized","unsigned short","unsigned short normalized"],NORMAL:["byte normalized","short normalized"],TANGENT:["byte normalized","short normalized"],TEXCOORD:["byte","byte normalized","unsigned byte","short","short normalized","unsigned short"]};class Q{constructor(){this.pluginCallbacks=[],this.register(function(e){return new Se(e)}),this.register(function(e){return new Le(e)}),this.register(function(e){return new Ue(e)}),this.register(function(e){return new Fe(e)}),this.register(function(e){return new Oe(e)}),this.register(function(e){return new ve(e)}),this.register(function(e){return new _e(e)}),this.register(function(e){return new Ce(e)}),this.register(function(e){return new De(e)}),this.register(function(e){return new ze(e)}),this.register(function(e){return new Pe(e)}),this.register(function(e){return new Be(e)}),this.register(function(e){return new Ge(e)})}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,s,n,t){const r=new be,i=[];for(let o=0,c=this.pluginCallbacks.length;o<c;o++)i.push(this.pluginCallbacks[o](r));r.setPlugins(i),r.write(e,s,t).catch(n)}parseAsync(e,s){const n=this;return new Promise(function(t,r){n.parse(e,t,r,s)})}}const g={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,BYTE:5120,UNSIGNED_BYTE:5121,SHORT:5122,UNSIGNED_SHORT:5123,INT:5124,UNSIGNED_INT:5125,FLOAT:5126,ARRAY_BUFFER:34962,ELEMENT_ARRAY_BUFFER:34963,NEAREST:9728,LINEAR:9729,NEAREST_MIPMAP_NEAREST:9984,LINEAR_MIPMAP_NEAREST:9985,NEAREST_MIPMAP_LINEAR:9986,LINEAR_MIPMAP_LINEAR:9987,CLAMP_TO_EDGE:33071,MIRRORED_REPEAT:33648,REPEAT:10497},G="KHR_mesh_quantization",R={};R[ue]=g.NEAREST;R[le]=g.NEAREST_MIPMAP_NEAREST;R[he]=g.NEAREST_MIPMAP_LINEAR;R[fe]=g.LINEAR;R[pe]=g.LINEAR_MIPMAP_NEAREST;R[de]=g.LINEAR_MIPMAP_LINEAR;R[xe]=g.CLAMP_TO_EDGE;R[ge]=g.REPEAT;R[Te]=g.MIRRORED_REPEAT;const K={scale:"scale",position:"translation",quaternion:"rotation",morphTargetInfluences:"weights"},ye=new se,q=12,me=1179937895,we=2,W=8,Ee=1313821514,Ie=5130562;function F(a,e){return a.length===e.length&&a.every(function(s,n){return s===e[n]})}function Ae(a){return new TextEncoder().encode(a).buffer}function Re(a){return F(a.elements,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}function Ne(a,e,s){const n={min:new Array(a.itemSize).fill(Number.POSITIVE_INFINITY),max:new Array(a.itemSize).fill(Number.NEGATIVE_INFINITY)};for(let t=e;t<e+s;t++)for(let r=0;r<a.itemSize;r++){let i;a.itemSize>4?i=a.array[t*a.itemSize+r]:(r===0?i=a.getX(t):r===1?i=a.getY(t):r===2?i=a.getZ(t):r===3&&(i=a.getW(t)),a.normalized===!0&&(i=H.normalize(i,a.array))),n.min[r]=Math.min(n.min[r],i),n.max[r]=Math.max(n.max[r],i)}return n}function $(a){return Math.ceil(a/4)*4}function k(a,e=0){const s=$(a.byteLength);if(s!==a.byteLength){const n=new Uint8Array(s);if(n.set(new Uint8Array(a)),e!==0)for(let t=a.byteLength;t<s;t++)n[t]=e;return n.buffer}return a}function X(){return typeof document>"u"&&typeof OffscreenCanvas<"u"?new OffscreenCanvas(1,1):document.createElement("canvas")}function J(a,e){if(a.toBlob!==void 0)return new Promise(n=>a.toBlob(n,e));let s;return e==="image/jpeg"?s=.92:e==="image/webp"&&(s=.8),a.convertToBlob({type:e,quality:s})}class be{constructor(){this.plugins=[],this.options={},this.pending=[],this.buffers=[],this.byteOffset=0,this.buffers=[],this.nodeMap=new Map,this.skins=[],this.extensionsUsed={},this.extensionsRequired={},this.uids=new Map,this.uid=0,this.json={asset:{version:"2.0",generator:"THREE.GLTFExporter"}},this.cache={meshes:new Map,attributes:new Map,attributesNormalized:new Map,materials:new Map,textures:new Map,images:new Map}}setPlugins(e){this.plugins=e}async write(e,s,n={}){this.options=Object.assign({binary:!1,trs:!1,onlyVisible:!0,maxTextureSize:1/0,animations:[],includeCustomExtensions:!1},n),this.options.animations.length>0&&(this.options.trs=!0),this.processInput(e),await Promise.all(this.pending);const t=this,r=t.buffers,i=t.json;n=t.options;const o=t.extensionsUsed,c=t.extensionsRequired,u=new Blob(r,{type:"application/octet-stream"}),p=Object.keys(o),h=Object.keys(c);if(p.length>0&&(i.extensionsUsed=p),h.length>0&&(i.extensionsRequired=h),i.buffers&&i.buffers.length>0&&(i.buffers[0].byteLength=u.size),n.binary===!0){const T=new FileReader;T.readAsArrayBuffer(u),T.onloadend=function(){const l=k(T.result),d=new DataView(new ArrayBuffer(W));d.setUint32(0,l.byteLength,!0),d.setUint32(4,Ie,!0);const f=k(Ae(JSON.stringify(i)),32),y=new DataView(new ArrayBuffer(W));y.setUint32(0,f.byteLength,!0),y.setUint32(4,Ee,!0);const m=new ArrayBuffer(q),N=new DataView(m);N.setUint32(0,me,!0),N.setUint32(4,we,!0);const O=q+y.byteLength+f.byteLength+d.byteLength+l.byteLength;N.setUint32(8,O,!0);const x=new Blob([m,y,f,d,l],{type:"application/octet-stream"}),M=new FileReader;M.readAsArrayBuffer(x),M.onloadend=function(){s(M.result)}}}else if(i.buffers&&i.buffers.length>0){const T=new FileReader;T.readAsDataURL(u),T.onloadend=function(){const l=T.result;i.buffers[0].uri=l,s(i)}}else s(i)}serializeUserData(e,s){if(Object.keys(e.userData).length===0)return;const n=this.options,t=this.extensionsUsed;try{const r=JSON.parse(JSON.stringify(e.userData));if(n.includeCustomExtensions&&r.gltfExtensions){s.extensions===void 0&&(s.extensions={});for(const i in r.gltfExtensions)s.extensions[i]=r.gltfExtensions[i],t[i]=!0;delete r.gltfExtensions}Object.keys(r).length>0&&(s.extras=r)}catch(r){console.warn("THREE.GLTFExporter: userData of '"+e.name+"' won't be serialized because of JSON.stringify error - "+r.message)}}getUID(e,s=!1){if(this.uids.has(e)===!1){const t=new Map;t.set(!0,this.uid++),t.set(!1,this.uid++),this.uids.set(e,t)}return this.uids.get(e).get(s)}isNormalizedNormalAttribute(e){if(this.cache.attributesNormalized.has(e))return!1;const n=new v;for(let t=0,r=e.count;t<r;t++)if(Math.abs(n.fromBufferAttribute(e,t).length()-1)>5e-4)return!1;return!0}createNormalizedNormalAttribute(e){const s=this.cache;if(s.attributesNormalized.has(e))return s.attributesNormalized.get(e);const n=e.clone(),t=new v;for(let r=0,i=n.count;r<i;r++)t.fromBufferAttribute(n,r),t.x===0&&t.y===0&&t.z===0?t.setX(1):t.normalize(),n.setXYZ(r,t.x,t.y,t.z);return s.attributesNormalized.set(e,n),n}applyTextureTransform(e,s){let n=!1;const t={};(s.offset.x!==0||s.offset.y!==0)&&(t.offset=s.offset.toArray(),n=!0),s.rotation!==0&&(t.rotation=s.rotation,n=!0),(s.repeat.x!==1||s.repeat.y!==1)&&(t.scale=s.repeat.toArray(),n=!0),n&&(e.extensions=e.extensions||{},e.extensions.KHR_texture_transform=t,this.extensionsUsed.KHR_texture_transform=!0)}buildMetalRoughTexture(e,s){if(e===s)return e;function n(l){return l.colorSpace===ce?function(f){return f<.04045?f*.0773993808:Math.pow(f*.9478672986+.0521327014,2.4)}:function(f){return f}}console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures."),e instanceof P&&(e=B(e)),s instanceof P&&(s=B(s));const t=e?e.image:null,r=s?s.image:null,i=Math.max(t?t.width:0,r?r.width:0),o=Math.max(t?t.height:0,r?r.height:0),c=X();c.width=i,c.height=o;const u=c.getContext("2d");u.fillStyle="#00ffff",u.fillRect(0,0,i,o);const p=u.getImageData(0,0,i,o);if(t){u.drawImage(t,0,0,i,o);const l=n(e),d=u.getImageData(0,0,i,o).data;for(let f=2;f<d.length;f+=4)p.data[f]=l(d[f]/256)*256}if(r){u.drawImage(r,0,0,i,o);const l=n(s),d=u.getImageData(0,0,i,o).data;for(let f=1;f<d.length;f+=4)p.data[f]=l(d[f]/256)*256}u.putImageData(p,0,0);const T=(e||s).clone();return T.source=new ne(c),T.colorSpace=ie,T.channel=(e||s).channel,e&&s&&e.channel!==s.channel&&console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match."),T}processBuffer(e){const s=this.json,n=this.buffers;return s.buffers||(s.buffers=[{byteLength:0}]),n.push(e),0}processBufferView(e,s,n,t,r){const i=this.json;i.bufferViews||(i.bufferViews=[]);let o;switch(s){case g.BYTE:case g.UNSIGNED_BYTE:o=1;break;case g.SHORT:case g.UNSIGNED_SHORT:o=2;break;default:o=4}const c=$(t*e.itemSize*o),u=new DataView(new ArrayBuffer(c));let p=0;for(let l=n;l<n+t;l++)for(let d=0;d<e.itemSize;d++){let f;e.itemSize>4?f=e.array[l*e.itemSize+d]:(d===0?f=e.getX(l):d===1?f=e.getY(l):d===2?f=e.getZ(l):d===3&&(f=e.getW(l)),e.normalized===!0&&(f=H.normalize(f,e.array))),s===g.FLOAT?u.setFloat32(p,f,!0):s===g.INT?u.setInt32(p,f,!0):s===g.UNSIGNED_INT?u.setUint32(p,f,!0):s===g.SHORT?u.setInt16(p,f,!0):s===g.UNSIGNED_SHORT?u.setUint16(p,f,!0):s===g.BYTE?u.setInt8(p,f):s===g.UNSIGNED_BYTE&&u.setUint8(p,f),p+=o}const h={buffer:this.processBuffer(u.buffer),byteOffset:this.byteOffset,byteLength:c};return r!==void 0&&(h.target=r),r===g.ARRAY_BUFFER&&(h.byteStride=e.itemSize*o),this.byteOffset+=c,i.bufferViews.push(h),{id:i.bufferViews.length-1,byteLength:0}}processBufferViewImage(e){const s=this,n=s.json;return n.bufferViews||(n.bufferViews=[]),new Promise(function(t){const r=new FileReader;r.readAsArrayBuffer(e),r.onloadend=function(){const i=k(r.result),o={buffer:s.processBuffer(i),byteOffset:s.byteOffset,byteLength:i.byteLength};s.byteOffset+=i.byteLength,t(n.bufferViews.push(o)-1)}})}processAccessor(e,s,n,t){const r=this.json,i={1:"SCALAR",2:"VEC2",3:"VEC3",4:"VEC4",9:"MAT3",16:"MAT4"};let o;if(e.array.constructor===Float32Array)o=g.FLOAT;else if(e.array.constructor===Int32Array)o=g.INT;else if(e.array.constructor===Uint32Array)o=g.UNSIGNED_INT;else if(e.array.constructor===Int16Array)o=g.SHORT;else if(e.array.constructor===Uint16Array)o=g.UNSIGNED_SHORT;else if(e.array.constructor===Int8Array)o=g.BYTE;else if(e.array.constructor===Uint8Array)o=g.UNSIGNED_BYTE;else throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type: "+e.array.constructor.name);if(n===void 0&&(n=0),(t===void 0||t===1/0)&&(t=e.count),t===0)return null;const c=Ne(e,n,t);let u;s!==void 0&&(u=e===s.index?g.ELEMENT_ARRAY_BUFFER:g.ARRAY_BUFFER);const p=this.processBufferView(e,o,n,t,u),h={bufferView:p.id,byteOffset:p.byteOffset,componentType:o,count:t,max:c.max,min:c.min,type:i[e.itemSize]};return e.normalized===!0&&(h.normalized=!0),r.accessors||(r.accessors=[]),r.accessors.push(h)-1}processImage(e,s,n,t="image/png"){if(e!==null){const r=this,i=r.cache,o=r.json,c=r.options,u=r.pending;i.images.has(e)||i.images.set(e,{});const p=i.images.get(e),h=t+":flipY/"+n.toString();if(p[h]!==void 0)return p[h];o.images||(o.images=[]);const T={mimeType:t},l=X();l.width=Math.min(e.width,c.maxTextureSize),l.height=Math.min(e.height,c.maxTextureSize);const d=l.getContext("2d");if(n===!0&&(d.translate(0,l.height),d.scale(1,-1)),e.data!==void 0){s!==re&&console.error("GLTFExporter: Only RGBAFormat is supported.",s),(e.width>c.maxTextureSize||e.height>c.maxTextureSize)&&console.warn("GLTFExporter: Image size is bigger than maxTextureSize",e);const y=new Uint8ClampedArray(e.height*e.width*4);for(let m=0;m<y.length;m+=4)y[m+0]=e.data[m+0],y[m+1]=e.data[m+1],y[m+2]=e.data[m+2],y[m+3]=e.data[m+3];d.putImageData(new ImageData(y,e.width,e.height),0,0)}else d.drawImage(e,0,0,l.width,l.height);c.binary===!0?u.push(J(l,t).then(y=>r.processBufferViewImage(y)).then(y=>{T.bufferView=y})):l.toDataURL!==void 0?T.uri=l.toDataURL(t):u.push(J(l,t).then(y=>new FileReader().readAsDataURL(y)).then(y=>{T.uri=y}));const f=o.images.push(T)-1;return p[h]=f,f}else throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.")}processSampler(e){const s=this.json;s.samplers||(s.samplers=[]);const n={magFilter:R[e.magFilter],minFilter:R[e.minFilter],wrapS:R[e.wrapS],wrapT:R[e.wrapT]};return s.samplers.push(n)-1}processTexture(e){const n=this.options,t=this.cache,r=this.json;if(t.textures.has(e))return t.textures.get(e);r.textures||(r.textures=[]),e instanceof P&&(e=B(e,n.maxTextureSize));let i=e.userData.mimeType;i==="image/webp"&&(i="image/png");const o={sampler:this.processSampler(e),source:this.processImage(e.image,e.format,e.flipY,i)};e.name&&(o.name=e.name),this._invokeAll(function(u){u.writeTexture&&u.writeTexture(e,o)});const c=r.textures.push(o)-1;return t.textures.set(e,c),c}processMaterial(e){const s=this.cache,n=this.json;if(s.materials.has(e))return s.materials.get(e);if(e.isShaderMaterial)return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."),null;n.materials||(n.materials=[]);const t={pbrMetallicRoughness:{}};e.isMeshStandardMaterial!==!0&&e.isMeshBasicMaterial!==!0&&console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");const r=e.color.toArray().concat([e.opacity]);if(F(r,[1,1,1,1])||(t.pbrMetallicRoughness.baseColorFactor=r),e.isMeshStandardMaterial?(t.pbrMetallicRoughness.metallicFactor=e.metalness,t.pbrMetallicRoughness.roughnessFactor=e.roughness):(t.pbrMetallicRoughness.metallicFactor=.5,t.pbrMetallicRoughness.roughnessFactor=.5),e.metalnessMap||e.roughnessMap){const o=this.buildMetalRoughTexture(e.metalnessMap,e.roughnessMap),c={index:this.processTexture(o),channel:o.channel};this.applyTextureTransform(c,o),t.pbrMetallicRoughness.metallicRoughnessTexture=c}if(e.map){const o={index:this.processTexture(e.map),texCoord:e.map.channel};this.applyTextureTransform(o,e.map),t.pbrMetallicRoughness.baseColorTexture=o}if(e.emissive){const o=e.emissive;if(Math.max(o.r,o.g,o.b)>0&&(t.emissiveFactor=e.emissive.toArray()),e.emissiveMap){const u={index:this.processTexture(e.emissiveMap),texCoord:e.emissiveMap.channel};this.applyTextureTransform(u,e.emissiveMap),t.emissiveTexture=u}}if(e.normalMap){const o={index:this.processTexture(e.normalMap),texCoord:e.normalMap.channel};e.normalScale&&e.normalScale.x!==1&&(o.scale=e.normalScale.x),this.applyTextureTransform(o,e.normalMap),t.normalTexture=o}if(e.aoMap){const o={index:this.processTexture(e.aoMap),texCoord:e.aoMap.channel};e.aoMapIntensity!==1&&(o.strength=e.aoMapIntensity),this.applyTextureTransform(o,e.aoMap),t.occlusionTexture=o}e.transparent?t.alphaMode="BLEND":e.alphaTest>0&&(t.alphaMode="MASK",t.alphaCutoff=e.alphaTest),e.side===oe&&(t.doubleSided=!0),e.name!==""&&(t.name=e.name),this.serializeUserData(e,t),this._invokeAll(function(o){o.writeMaterial&&o.writeMaterial(e,t)});const i=n.materials.push(t)-1;return s.materials.set(e,i),i}processMesh(e){const s=this.cache,n=this.json,t=[e.geometry.uuid];if(Array.isArray(e.material))for(let x=0,M=e.material.length;x<M;x++)t.push(e.material[x].uuid);else t.push(e.material.uuid);const r=t.join(":");if(s.meshes.has(r))return s.meshes.get(r);const i=e.geometry;let o;e.isLineSegments?o=g.LINES:e.isLineLoop?o=g.LINE_LOOP:e.isLine?o=g.LINE_STRIP:e.isPoints?o=g.POINTS:o=e.material.wireframe?g.LINES:g.TRIANGLES;const c={},u={},p=[],h=[],T={uv:"TEXCOORD_0",uv1:"TEXCOORD_1",uv2:"TEXCOORD_2",uv3:"TEXCOORD_3",color:"COLOR_0",skinWeight:"WEIGHTS_0",skinIndex:"JOINTS_0"},l=i.getAttribute("normal");l!==void 0&&!this.isNormalizedNormalAttribute(l)&&(console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),i.setAttribute("normal",this.createNormalizedNormalAttribute(l)));let d=null;for(let x in i.attributes){if(x.slice(0,5)==="morph")continue;const M=i.attributes[x];if(x=T[x]||x.toUpperCase(),/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(x)||(x="_"+x),s.attributes.has(this.getUID(M))){u[x]=s.attributes.get(this.getUID(M));continue}d=null;const E=M.array;x==="JOINTS_0"&&!(E instanceof Uint16Array)&&!(E instanceof Uint8Array)&&(console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),d=new S(new Uint16Array(E),M.itemSize,M.normalized));const A=this.processAccessor(d||M,i);A!==null&&(x.startsWith("_")||this.detectMeshQuantization(x,M),u[x]=A,s.attributes.set(this.getUID(M),A))}if(l!==void 0&&i.setAttribute("normal",l),Object.keys(u).length===0)return null;if(e.morphTargetInfluences!==void 0&&e.morphTargetInfluences.length>0){const x=[],M=[],w={};if(e.morphTargetDictionary!==void 0)for(const E in e.morphTargetDictionary)w[e.morphTargetDictionary[E]]=E;for(let E=0;E<e.morphTargetInfluences.length;++E){const A={};let V=!1;for(const _ in i.morphAttributes){if(_!=="position"&&_!=="normal"){V||(console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),V=!0);continue}const b=i.morphAttributes[_][E],z=_.toUpperCase(),C=i.attributes[_];if(s.attributes.has(this.getUID(b,!0))){A[z]=s.attributes.get(this.getUID(b,!0));continue}const U=b.clone();if(!i.morphTargetsRelative)for(let I=0,ee=b.count;I<ee;I++)for(let L=0;L<b.itemSize;L++)L===0&&U.setX(I,b.getX(I)-C.getX(I)),L===1&&U.setY(I,b.getY(I)-C.getY(I)),L===2&&U.setZ(I,b.getZ(I)-C.getZ(I)),L===3&&U.setW(I,b.getW(I)-C.getW(I));A[z]=this.processAccessor(U,i),s.attributes.set(this.getUID(C,!0),A[z])}h.push(A),x.push(e.morphTargetInfluences[E]),e.morphTargetDictionary!==void 0&&M.push(w[E])}c.weights=x,M.length>0&&(c.extras={},c.extras.targetNames=M)}const f=Array.isArray(e.material);if(f&&i.groups.length===0)return null;let y=!1;if(f&&i.index===null){const x=[];for(let M=0,w=i.attributes.position.count;M<w;M++)x[M]=M;i.setIndex(x),y=!0}const m=f?e.material:[e.material],N=f?i.groups:[{materialIndex:0,start:void 0,count:void 0}];for(let x=0,M=N.length;x<M;x++){const w={mode:o,attributes:u};if(this.serializeUserData(i,w),h.length>0&&(w.targets=h),i.index!==null){let A=this.getUID(i.index);(N[x].start!==void 0||N[x].count!==void 0)&&(A+=":"+N[x].start+":"+N[x].count),s.attributes.has(A)?w.indices=s.attributes.get(A):(w.indices=this.processAccessor(i.index,i,N[x].start,N[x].count),s.attributes.set(A,w.indices)),w.indices===null&&delete w.indices}const E=this.processMaterial(m[N[x].materialIndex]);E!==null&&(w.material=E),p.push(w)}y===!0&&i.setIndex(null),c.primitives=p,n.meshes||(n.meshes=[]),this._invokeAll(function(x){x.writeMesh&&x.writeMesh(e,c)});const O=n.meshes.push(c)-1;return s.meshes.set(r,O),O}detectMeshQuantization(e,s){if(this.extensionsUsed[G])return;let n;switch(s.array.constructor){case Int8Array:n="byte";break;case Uint8Array:n="unsigned byte";break;case Int16Array:n="short";break;case Uint16Array:n="unsigned short";break;default:return}s.normalized&&(n+=" normalized");const t=e.split("_",1)[0];j[t]&&j[t].includes(n)&&(this.extensionsUsed[G]=!0,this.extensionsRequired[G]=!0)}processCamera(e){const s=this.json;s.cameras||(s.cameras=[]);const n=e.isOrthographicCamera,t={type:n?"orthographic":"perspective"};return n?t.orthographic={xmag:e.right*2,ymag:e.top*2,zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near}:t.perspective={aspectRatio:e.aspect,yfov:H.degToRad(e.fov),zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near},e.name!==""&&(t.name=e.type),s.cameras.push(t)-1}processAnimation(e,s){const n=this.json,t=this.nodeMap;n.animations||(n.animations=[]),e=Q.Utils.mergeMorphTargetTracks(e.clone(),s);const r=e.tracks,i=[],o=[];for(let c=0;c<r.length;++c){const u=r[c],p=D.parseTrackName(u.name);let h=D.findNode(s,p.nodeName);const T=K[p.propertyName];if(p.objectName==="bones"&&(h.isSkinnedMesh===!0?h=h.skeleton.getBoneByName(p.objectIndex):h=void 0),!h||!T)return console.warn('THREE.GLTFExporter: Could not export animation track "%s".',u.name),null;const l=1;let d=u.values.length/u.times.length;T===K.morphTargetInfluences&&(d/=h.morphTargetInfluences.length);let f;u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline===!0?(f="CUBICSPLINE",d/=3):u.getInterpolation()===ae?f="STEP":f="LINEAR",o.push({input:this.processAccessor(new S(u.times,l)),output:this.processAccessor(new S(u.values,d)),interpolation:f}),i.push({sampler:o.length-1,target:{node:t.get(h),path:T}})}return n.animations.push({name:e.name||"clip_"+n.animations.length,samplers:o,channels:i}),n.animations.length-1}processSkin(e){const s=this.json,n=this.nodeMap,t=s.nodes[n.get(e)],r=e.skeleton;if(r===void 0)return null;const i=e.skeleton.bones[0];if(i===void 0)return null;const o=[],c=new Float32Array(r.bones.length*16),u=new Z;for(let h=0;h<r.bones.length;++h)o.push(n.get(r.bones[h])),u.copy(r.boneInverses[h]),u.multiply(e.bindMatrix).toArray(c,h*16);return s.skins===void 0&&(s.skins=[]),s.skins.push({inverseBindMatrices:this.processAccessor(new S(c,16)),joints:o,skeleton:n.get(i)}),t.skin=s.skins.length-1}processNode(e){const s=this.json,n=this.options,t=this.nodeMap;s.nodes||(s.nodes=[]);const r={};if(n.trs){const o=e.quaternion.toArray(),c=e.position.toArray(),u=e.scale.toArray();F(o,[0,0,0,1])||(r.rotation=o),F(c,[0,0,0])||(r.translation=c),F(u,[1,1,1])||(r.scale=u)}else e.matrixAutoUpdate&&e.updateMatrix(),Re(e.matrix)===!1&&(r.matrix=e.matrix.elements);if(e.name!==""&&(r.name=String(e.name)),this.serializeUserData(e,r),e.isMesh||e.isLine||e.isPoints){const o=this.processMesh(e);o!==null&&(r.mesh=o)}else e.isCamera&&(r.camera=this.processCamera(e));if(e.isSkinnedMesh&&this.skins.push(e),e.children.length>0){const o=[];for(let c=0,u=e.children.length;c<u;c++){const p=e.children[c];if(p.visible||n.onlyVisible===!1){const h=this.processNode(p);h!==null&&o.push(h)}}o.length>0&&(r.children=o)}this._invokeAll(function(o){o.writeNode&&o.writeNode(e,r)});const i=s.nodes.push(r)-1;return t.set(e,i),i}processScene(e){const s=this.json,n=this.options;s.scenes||(s.scenes=[],s.scene=0);const t={};e.name!==""&&(t.name=e.name),s.scenes.push(t);const r=[];for(let i=0,o=e.children.length;i<o;i++){const c=e.children[i];if(c.visible||n.onlyVisible===!1){const u=this.processNode(c);u!==null&&r.push(u)}}r.length>0&&(t.nodes=r),this.serializeUserData(e,t)}processObjects(e){const s=new Y;s.name="AuxScene";for(let n=0;n<e.length;n++)s.children.push(e[n]);this.processScene(s)}processInput(e){const s=this.options;e=e instanceof Array?e:[e],this._invokeAll(function(t){t.beforeParse&&t.beforeParse(e)});const n=[];for(let t=0;t<e.length;t++)e[t]instanceof Y?this.processScene(e[t]):n.push(e[t]);n.length>0&&this.processObjects(n);for(let t=0;t<this.skins.length;++t)this.processSkin(this.skins[t]);for(let t=0;t<s.animations.length;++t)this.processAnimation(s.animations[t],e[0]);this._invokeAll(function(t){t.afterParse&&t.afterParse(e)})}_invokeAll(e){for(let s=0,n=this.plugins.length;s<n;s++)e(this.plugins[s])}}class Se{constructor(e){this.writer=e,this.name="KHR_lights_punctual"}writeNode(e,s){if(!e.isLight)return;if(!e.isDirectionalLight&&!e.isPointLight&&!e.isSpotLight){console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.",e);return}const n=this.writer,t=n.json,r=n.extensionsUsed,i={};e.name&&(i.name=e.name),i.color=e.color.toArray(),i.intensity=e.intensity,e.isDirectionalLight?i.type="directional":e.isPointLight?(i.type="point",e.distance>0&&(i.range=e.distance)):e.isSpotLight&&(i.type="spot",e.distance>0&&(i.range=e.distance),i.spot={},i.spot.innerConeAngle=(1-e.penumbra)*e.angle,i.spot.outerConeAngle=e.angle),e.decay!==void 0&&e.decay!==2&&console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."),e.target&&(e.target.parent!==e||e.target.position.x!==0||e.target.position.y!==0||e.target.position.z!==-1)&&console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."),r[this.name]||(t.extensions=t.extensions||{},t.extensions[this.name]={lights:[]},r[this.name]=!0);const o=t.extensions[this.name].lights;o.push(i),s.extensions=s.extensions||{},s.extensions[this.name]={light:o.length-1}}}class Le{constructor(e){this.writer=e,this.name="KHR_materials_unlit"}writeMaterial(e,s){if(!e.isMeshBasicMaterial)return;const t=this.writer.extensionsUsed;s.extensions=s.extensions||{},s.extensions[this.name]={},t[this.name]=!0,s.pbrMetallicRoughness.metallicFactor=0,s.pbrMetallicRoughness.roughnessFactor=.9}}class _e{constructor(e){this.writer=e,this.name="KHR_materials_clearcoat"}writeMaterial(e,s){if(!e.isMeshPhysicalMaterial||e.clearcoat===0)return;const n=this.writer,t=n.extensionsUsed,r={};if(r.clearcoatFactor=e.clearcoat,e.clearcoatMap){const i={index:n.processTexture(e.clearcoatMap),texCoord:e.clearcoatMap.channel};n.applyTextureTransform(i,e.clearcoatMap),r.clearcoatTexture=i}if(r.clearcoatRoughnessFactor=e.clearcoatRoughness,e.clearcoatRoughnessMap){const i={index:n.processTexture(e.clearcoatRoughnessMap),texCoord:e.clearcoatRoughnessMap.channel};n.applyTextureTransform(i,e.clearcoatRoughnessMap),r.clearcoatRoughnessTexture=i}if(e.clearcoatNormalMap){const i={index:n.processTexture(e.clearcoatNormalMap),texCoord:e.clearcoatNormalMap.channel};n.applyTextureTransform(i,e.clearcoatNormalMap),r.clearcoatNormalTexture=i}s.extensions=s.extensions||{},s.extensions[this.name]=r,t[this.name]=!0}}class Ce{constructor(e){this.writer=e,this.name="KHR_materials_iridescence"}writeMaterial(e,s){if(!e.isMeshPhysicalMaterial||e.iridescence===0)return;const n=this.writer,t=n.extensionsUsed,r={};if(r.iridescenceFactor=e.iridescence,e.iridescenceMap){const i={index:n.processTexture(e.iridescenceMap),texCoord:e.iridescenceMap.channel};n.applyTextureTransform(i,e.iridescenceMap),r.iridescenceTexture=i}if(r.iridescenceIor=e.iridescenceIOR,r.iridescenceThicknessMinimum=e.iridescenceThicknessRange[0],r.iridescenceThicknessMaximum=e.iridescenceThicknessRange[1],e.iridescenceThicknessMap){const i={index:n.processTexture(e.iridescenceThicknessMap),texCoord:e.iridescenceThicknessMap.channel};n.applyTextureTransform(i,e.iridescenceThicknessMap),r.iridescenceThicknessTexture=i}s.extensions=s.extensions||{},s.extensions[this.name]=r,t[this.name]=!0}}class Ue{constructor(e){this.writer=e,this.name="KHR_materials_transmission"}writeMaterial(e,s){if(!e.isMeshPhysicalMaterial||e.transmission===0)return;const n=this.writer,t=n.extensionsUsed,r={};if(r.transmissionFactor=e.transmission,e.transmissionMap){const i={index:n.processTexture(e.transmissionMap),texCoord:e.transmissionMap.channel};n.applyTextureTransform(i,e.transmissionMap),r.transmissionTexture=i}s.extensions=s.extensions||{},s.extensions[this.name]=r,t[this.name]=!0}}class Fe{constructor(e){this.writer=e,this.name="KHR_materials_volume"}writeMaterial(e,s){if(!e.isMeshPhysicalMaterial||e.transmission===0)return;const n=this.writer,t=n.extensionsUsed,r={};if(r.thicknessFactor=e.thickness,e.thicknessMap){const i={index:n.processTexture(e.thicknessMap),texCoord:e.thicknessMap.channel};n.applyTextureTransform(i,e.thicknessMap),r.thicknessTexture=i}r.attenuationDistance=e.attenuationDistance,r.attenuationColor=e.attenuationColor.toArray(),s.extensions=s.extensions||{},s.extensions[this.name]=r,t[this.name]=!0}}class Oe{constructor(e){this.writer=e,this.name="KHR_materials_ior"}writeMaterial(e,s){if(!e.isMeshPhysicalMaterial||e.ior===1.5)return;const t=this.writer.extensionsUsed,r={};r.ior=e.ior,s.extensions=s.extensions||{},s.extensions[this.name]=r,t[this.name]=!0}}class ve{constructor(e){this.writer=e,this.name="KHR_materials_specular"}writeMaterial(e,s){if(!e.isMeshPhysicalMaterial||e.specularIntensity===1&&e.specularColor.equals(ye)&&!e.specularIntensityMap&&!e.specularColorMap)return;const n=this.writer,t=n.extensionsUsed,r={};if(e.specularIntensityMap){const i={index:n.processTexture(e.specularIntensityMap),texCoord:e.specularIntensityMap.channel};n.applyTextureTransform(i,e.specularIntensityMap),r.specularTexture=i}if(e.specularColorMap){const i={index:n.processTexture(e.specularColorMap),texCoord:e.specularColorMap.channel};n.applyTextureTransform(i,e.specularColorMap),r.specularColorTexture=i}r.specularFactor=e.specularIntensity,r.specularColorFactor=e.specularColor.toArray(),s.extensions=s.extensions||{},s.extensions[this.name]=r,t[this.name]=!0}}class De{constructor(e){this.writer=e,this.name="KHR_materials_sheen"}writeMaterial(e,s){if(!e.isMeshPhysicalMaterial||e.sheen==0)return;const n=this.writer,t=n.extensionsUsed,r={};if(e.sheenRoughnessMap){const i={index:n.processTexture(e.sheenRoughnessMap),texCoord:e.sheenRoughnessMap.channel};n.applyTextureTransform(i,e.sheenRoughnessMap),r.sheenRoughnessTexture=i}if(e.sheenColorMap){const i={index:n.processTexture(e.sheenColorMap),texCoord:e.sheenColorMap.channel};n.applyTextureTransform(i,e.sheenColorMap),r.sheenColorTexture=i}r.sheenRoughnessFactor=e.sheenRoughness,r.sheenColorFactor=e.sheenColor.toArray(),s.extensions=s.extensions||{},s.extensions[this.name]=r,t[this.name]=!0}}class ze{constructor(e){this.writer=e,this.name="KHR_materials_anisotropy"}writeMaterial(e,s){if(!e.isMeshPhysicalMaterial||e.anisotropy==0)return;const n=this.writer,t=n.extensionsUsed,r={};if(e.anisotropyMap){const i={index:n.processTexture(e.anisotropyMap)};n.applyTextureTransform(i,e.anisotropyMap),r.anisotropyTexture=i}r.anisotropyStrength=e.anisotropy,r.anisotropyRotation=e.anisotropyRotation,s.extensions=s.extensions||{},s.extensions[this.name]=r,t[this.name]=!0}}class Pe{constructor(e){this.writer=e,this.name="KHR_materials_emissive_strength"}writeMaterial(e,s){if(!e.isMeshStandardMaterial||e.emissiveIntensity===1)return;const t=this.writer.extensionsUsed,r={};r.emissiveStrength=e.emissiveIntensity,s.extensions=s.extensions||{},s.extensions[this.name]=r,t[this.name]=!0}}class Be{constructor(e){this.writer=e,this.name="EXT_materials_bump"}writeMaterial(e,s){if(!e.isMeshStandardMaterial||e.bumpScale===1&&!e.bumpMap)return;const n=this.writer,t=n.extensionsUsed,r={};if(e.bumpMap){const i={index:n.processTexture(e.bumpMap),texCoord:e.bumpMap.channel};n.applyTextureTransform(i,e.bumpMap),r.bumpTexture=i}r.bumpFactor=e.bumpScale,s.extensions=s.extensions||{},s.extensions[this.name]=r,t[this.name]=!0}}class Ge{constructor(e){this.writer=e,this.name="EXT_mesh_gpu_instancing"}writeNode(e,s){if(!e.isInstancedMesh)return;const n=this.writer,t=e,r=new Float32Array(t.count*3),i=new Float32Array(t.count*4),o=new Float32Array(t.count*3),c=new Z,u=new v,p=new te,h=new v;for(let l=0;l<t.count;l++)t.getMatrixAt(l,c),c.decompose(u,p,h),u.toArray(r,l*3),p.toArray(i,l*4),h.toArray(o,l*3);const T={TRANSLATION:n.processAccessor(new S(r,3)),ROTATION:n.processAccessor(new S(i,4)),SCALE:n.processAccessor(new S(o,3))};t.instanceColor&&(T._COLOR_0=n.processAccessor(t.instanceColor)),s.extensions=s.extensions||{},s.extensions[this.name]={attributes:T},n.extensionsUsed[this.name]=!0,n.extensionsRequired[this.name]=!0}}Q.Utils={insertKeyframe:function(a,e){const n=a.getValueSize(),t=new a.TimeBufferType(a.times.length+1),r=new a.ValueBufferType(a.values.length+n),i=a.createInterpolant(new a.ValueBufferType(n));let o;if(a.times.length===0){t[0]=e;for(let c=0;c<n;c++)r[c]=0;o=0}else if(e<a.times[0]){if(Math.abs(a.times[0]-e)<.001)return 0;t[0]=e,t.set(a.times,1),r.set(i.evaluate(e),0),r.set(a.values,n),o=0}else if(e>a.times[a.times.length-1]){if(Math.abs(a.times[a.times.length-1]-e)<.001)return a.times.length-1;t[t.length-1]=e,t.set(a.times,0),r.set(a.values,0),r.set(i.evaluate(e),a.values.length),o=t.length-1}else for(let c=0;c<a.times.length;c++){if(Math.abs(a.times[c]-e)<.001)return c;if(a.times[c]<e&&a.times[c+1]>e){t.set(a.times.slice(0,c+1),0),t[c+1]=e,t.set(a.times.slice(c+1),c+2),r.set(a.values.slice(0,(c+1)*n),0),r.set(i.evaluate(e),(c+1)*n),r.set(a.values.slice((c+1)*n),(c+2)*n),o=c+1;break}}return a.times=t,a.values=r,o},mergeMorphTargetTracks:function(a,e){const s=[],n={},t=a.tracks;for(let r=0;r<t.length;++r){let i=t[r];const o=D.parseTrackName(i.name),c=D.findNode(e,o.nodeName);if(o.propertyName!=="morphTargetInfluences"||o.propertyIndex===void 0){s.push(i);continue}if(i.createInterpolant!==i.InterpolantFactoryMethodDiscrete&&i.createInterpolant!==i.InterpolantFactoryMethodLinear){if(i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),i=i.clone(),i.setInterpolation(Me)}const u=c.morphTargetInfluences.length,p=c.morphTargetDictionary[o.propertyIndex];if(p===void 0)throw new Error("THREE.GLTFExporter: Morph target name not found: "+o.propertyIndex);let h;if(n[c.uuid]===void 0){h=i.clone();const l=new h.ValueBufferType(u*h.times.length);for(let d=0;d<h.times.length;d++)l[d*u+p]=h.values[d];h.name=(o.nodeName||"")+".morphTargetInfluences",h.values=l,n[c.uuid]=h,s.push(h);continue}const T=i.createInterpolant(new i.ValueBufferType(1));h=n[c.uuid];for(let l=0;l<h.times.length;l++)h.values[l*u+p]=T.evaluate(h.times[l]);for(let l=0;l<i.times.length;l++){const d=this.insertKeyframe(h,i.times[l]);h.values[d*u+p]=i.values[l]}}return a.tracks=s,a}};export{Q as GLTFExporter};
